; TRABALHO 1 - ARQUITETURA DE COMPUTADORES 1
; UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL
;
; Autor: Wellington Espindula (wmespindula@inf.ufrgs.br)
; #: 00302367
;
; Resumo: O presente trabalho tem por objetivo implementar, na máquina teórica Ramses, um programa que processe um 
; vetor contendo valores de 16 bits (2 bytes por elemento) e forneça um resultado também em 16 bits. O processamento
; dos dados consiste em: (i) Girar o primeiro e o segundo byte do elemento para a direita em 4 bits; (ii) Permutar 
; os valores do primeiro e do segundo byte; (iii) Somar o resultado obtido (com 16 bits) à variável que armazena 
; o resultado. Por fim, o programa, usando o resultado do processamento do vetor, faz as permutações (i) e (ii). 
;


; VARIÁVEIS
ORG 128					; VARIÁVEIS DO PROGRAMA (AUXILIARES)
aux_msb:	DB 0			; guarda resultado do registrador A para permurtar com o B
aux_lsb:	DB 0			; guarda resultado do registrador B para permurtar com o A


ORG 197					; DADOS DE ENTRADA E SAÍDA
end_vetor:	DB 0			; Endereço do vetor de entrada
resultado_msb:	DB 0			; Byte mais significativo do resultado
resultado_lsb:	DB 0			; Byte menos significativo do resultado

; PROGRAMA
ORG 0
zera_variaveis:				; Zera as variáveis auxiliares e resultado
	LDR A #0			; Carrega 0 no registrador A
	STR A aux_msb			; Zera...
	STR A aux_lsb
	STR A resultado_msb
	STR A resultado_lsb
	
inicio:					; Início do programa em si
inicializa_loop_percorre_vetor:		; Inicializa variáveis necessárias para o laço que irá percorrer o vetor
	LDR X end_vetor			; Copia o endereço do início do vetor para o registrador X

loop_percorre_vetor:			; Loop que percorre o vetor...
	LDR A 0,X			; Carrega o primeiro byte do elemento do vetor no registrador A
	OR A 1,X			; Faz o primeiro byte ou o segundo byte do elemento do vetor
	JZ fim_do_loop_percorre_vetor	; Caso a soma dê zero, indica que houve a soma 0 e 0 ou uma soma que resulte em carry
	LDR A 0,X			; Carrega o primeiro byte do elemento do vetor no registrador A
	LDR B 1,X			; Carrega o segundo byte do elemento do vetor no registrador B
	JSR subrotina_processamento	; Processa os dados na subrotina...
					; Como pode-se notar, os dados são passados para a subrotina por registradores (A e B)
					; E o resultado da subrotina também é passado pelos registradores (A e B)

					; Volta da subrotina!!!

soma_A_B:				; Após o processamento dos dados, com os registradores A e B atualizados, soma os resultados com os resultados anteriores
	ADD A resultado_msb		; Soma o registrador A com o byte mais significativo do resultado
	ADD B resultado_lsb		; Soma o registrador B com o byte menos significativo do resultado
	JC carry_soma_b			; Caso na soma dos bytes menos significativos dê carry, soma 1 em A
	JMP salva_resultado_A_B		; Caso não dê carry, salva os resultados das somas, realizados nos registradores, nos endereços de memória

carry_soma_b:				; No caso de carry descrito acima, soma 1 no registrador A
	ADD A #1			; Soma 1 no registrador A...

salva_resultado_A_B:			; Salva os resultados das somas nos endereços de memória (saída)
	STR A resultado_msb		; Salva o registrador A no endereço de memória do byte mais significativo do resultado
	STR B resultado_lsb		; Salva o registrador B no endereço de memória do byte menos significativo do resultado

verifica_loop:				; Como os dados do elemento do vetor foram processados e salvos, então continua o laço
	LDR X end_vetor			; Carrega no registrador X o endereço atual (index) do vetor 
	ADD X #2			; Como são dois bytes para cada elemento, soma 2. Portanto, desloca o endereço para o próximo elemento do vetor
	STR X end_vetor			; Atualiza o registrador X
	JMP loop_percorre_vetor		; Volta para a verificação do laço

fim_do_loop_percorre_vetor:		; Caso tenha encontrado o elemento (0, 0), realiza as operações finais de processamento de dados no resultado já obtido e os salva
	LDR A resultado_msb		; Carrega o byte mais significativo do resultado no registrador A
	LDR B resultado_lsb		; Carrega o byte menos significativo do resultado no registrador B
	JSR subrotina_processamento	; Processa os dados na subrotina...
	STR A resultado_msb		; Salva os dados de saída da subrotina nos endereços de resultado
	STR B resultado_lsb		

fim:					; Fim!!!
	HLT


; SUBROTINA QUE REALIZA AS OPERAÇÕES DE PROCESSAMENTO NOS ELEMENTOS DO VETOR
; Realiza as operações de:
; 1 - Girar o registrador A para a direita em 4 bits
; 2 - Girar o registrador B para a direita em 4 bits
; 3 - Permutar os valores de A e B
;
subrotina_processamento:
	NOP

inicializa_loop_gira_byte:		; Inicializa dados necessários para o loop que irá girar os bytes nos registradores A e B
	LDR X #4			; Como o loop irá se repetir 4 vezes, carrega 4 no registrador X (registrador de índice).

loop_gira_byte:				; Loop que irá girar os bytes A e B
gira_byte_A:				; Gira o byte no registrador A
	SHR A				; Shifta o A para a direita
	JC carry_A			; Caso dê carry, pula para o carry_A, que irá implementar a operação de rotação

gira_byte_B:				; Gira o byte no registrador B
	SHR B				; Shifta o B para a direita
	JC carry_B			; Caso dê carry, pula para o carry_B, que irá implementar a operação de rotação
	JMP verifica_loop_gira_byte	; Caso não dê carry, pula para a verificação do laço

carry_A:				; Caso dê carry no shift para a direita, adiciona 1 ao bit mais significativo do byte
	OR A #128			; Adiciona 1 no bit mais significativo do byte em A
	JMP gira_byte_B			; pula para a operação de girar o byte em B

carry_B:				; Caso dê carry no shift para a direita, adiciona 1 ao bit mais significativo do byte
	OR B #128			; Adiciona 1 no bit mais significativo do byte em B

verifica_loop_gira_byte:		; Verifica laço
	SUB X #1			; Subtrai 1 do índice (registrador X)
	JZ inverte_A_B			; Caso tenha chegado a 0, ou seja, já tenha percorrido o laço 4 vezes, pula para as operações subsequentes
	JMP loop_gira_byte		; Caso não tenha chegado a 0, continua o laço...

inverte_A_B: 				; Permuta o resultado em A com o resultado em B
	STR A aux_msb			; Utilizando um endereço auxiliar, armazena o que está em A nesse registrador
	STR B aux_lsb			; Idem com B
	LDR A aux_lsb			; Carrega em A o que estava em B
	LDR B aux_msb			; Carrega em B o que estava em A

volta_subrotina:			; Retorna...
	JMP subrotina_processamento,I	;