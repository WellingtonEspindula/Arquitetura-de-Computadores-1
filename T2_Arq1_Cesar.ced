; programa

; Constantes com os codigos das funcoes do sistema (ver enunciado)
kbhit:    equ 0
getchar:  equ 1
gettime:  equ 2
putchar:  equ 3
putmsg:   equ 4

;------------------------------------------------------------------------------
; Definição de endereços necessários para o desenvolvimento da aplicação
;------------------------------------------------------------------------------
_APP:		equ	h0100		; inicio da APP
_SISTEMA:	equ	h0080		; area das syscall
_VARS:		equ	h400		; variáveis da aplicação
_WORDS:		equ	h500		; mensagens e tabela de palavras

org _VARS
posicao_cursor:	db 0
num_carac_dig:	db 0			; numero de caracteres digitados pelo usuario no display
		db 0
palavra_atual:	dab '        '		; palavra usada no jogo, sorteada no início de cada partida
palavra_dig:	dab '        '		; palavra digitada pelo usuário

org _WORDS
esp_dois_pontos:dab ' : '
limpa_visor:	dab '                                    '	; visor em branco
cursor:		dab '_'
tab_seqs:	dab 'abcdefgh'		; índice 0
		dab 'aaaaaaaa'		; índice 1 
		dab 'AAAAAAAA'		; índice 2 
		dab 'bbbbbbbb'		; índice 3 
		dab 'BBBBBBBB'		; índice 4 
		dab 'cccccccc'		; índice 5 
		dab 'CCCCCCCC'		; índice 6 
		dab 'dddddddd'		; índice 7 
		dab 'DDDDDDDD'		; índice 8 
		dab 'eeeeeeee'		; índice 9 
		dab 'EEEEEEEE'		; índice 10
		dab 'ffffffff'		; índice 11
		dab 'FFFFFFFF'		; índice 12
		dab 'gggggggg'		; índice 13
		dab 'GGGGGGGG'		; índice 14
		dab 'hhhhhhhh'		; índice 15


org _APP
inicio:	
	CLR R1
	CLR R2
	CLR R3
	CLR R4
	CLR R5

;	MOV #kbhit, R5	; while (kbhit())
;	JSR R7, _SISTEMA
;	TST R0
;	BEQ inicio


palavra_aleatoria:
	MOV #gettime, R5
	JSR R7,_SISTEMA
	AND #15, R0
	ASL R0
	ASL R0
	ASL R0

cp_palavra_transf:
	MOV #4, R3	

	ADD #tab_seqs, R0	
	MOV #palavra_atual, R1


loop_cp:
	MOV (R0)+, (R1)+
	SOB R3, loop_cp

puts:	
	MOV #putmsg, R5			; modo putmsg
	MOV #palavra_atual, R0
	MOV #0, R1			; começa a escrever na primeira posição do visor
	JSR R7, _SISTEMA

	MOV #esp_dois_pontos, R3
	MOV #putchar, R5
	MOV -1(R3), R0
	MOV #8, R1
	JSR R7, _SISTEMA
	MOV #putchar, R5
	MOV (R3), R0
	INC R1
	JSR R7, _SISTEMA
	MOV #putchar, R5
	MOV 1(R3), R0
	INC R1
	JSR R7, _SISTEMA	

inicia_entrada:
	
houve_entrada:
	MOV #kbhit, R5			; while (kbhit())
	JSR R7, _SISTEMA
	TST R0
	BEQ houve_entrada

trata_entrada:
	MOV #getchar, R5		; r0 = getchar()
	JSR R7, _SISTEMA


; Verifica se o caractere digitado é alfanumérico
comparacao_1:
	CMP #'0', R0			; r0 >= 48 (0)
	BGT comparacao_2

	CMP #'9', R0			; r0 <= 57 (9)
	BLT comparacao_2
	
	JMP add_carac
	
comparacao_2:
	CMP #'A', R0			; r0 >= 65 (A)
	BGT comparacao_3

	CMP #'Z', R0			; r0 <= 90 (Z)
	BLT comparacao_3

	JMP add_carac
	
comparacao_3:
	CMP #'a', R0			; r0 >= 97 (a)
	BGT carac_fora_escopo

	CMP #'z', R0			; r0 <= 122 (z)
	BLT carac_fora_escopo
	
	JMP add_carac

;Verifica se é um enter ou um backspace
carac_fora_escopo:
	CMP #8, R0			; verifica se o usuário entrou com backspace
	BEQ bkspc
	CMP #13, R0
	BEQ enter
	JMP inicia_entrada

bkspc:
	MOV #putchar, R5
	MOV #'!', R0
	MOV #11, R1
	JSR R7, _SISTEMA
	JMP inicia_entrada

enter:
	MOV #putchar, R5
	MOV #'-', R0
	MOV #11, R1
	JSR R7, _SISTEMA
	JMP inicia_entrada

add_carac:
	MOV num_carac_dig, R2	; R2 = num_carac_dig
	CMP #8, R2		; R2 == 8 (ASCII backspace)
	BEQ display_cheio
	MOV #palavra_dig, R3 	; R3 = end_palavra_dig
	ADD R2, R3		; i = end_palavra_dig + num_carac_dig
	MOV R0, (R3)		; palavra_dig[i] = entrada 
				; Ou seja, move o caractere entrado para a memória

	MOV #putchar, R5	; modo putchar
	MOV R2, R0
	MOV #11, R1		; Inicia a digitacao na 12ª posicao do display
	ADD R2, R1		; R1 += R2 ou R1 +=  num_carac_dig
				; Isto é, adiciona o numero de caractere digitados no R1
	JSR R7, _SISTEMA

	INC num_carac_dig
	JMP inicia_entrada

display_cheio:
	MOV #putchar, R5
	MOV #'#', R0
	MOV #11, R1
	JSR R7, _SISTEMA
	JMP inicia_entrada

fim:
	HLT