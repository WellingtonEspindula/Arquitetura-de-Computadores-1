;************************************************************************************
;
; Arquivo base para desenvolvimento do KERNEL - parte 2 do trabalho com o Cesar
;
; Versao: 2019.1.0
;
; Areas de memoria:
;
;     0000 - 007F (0 - 127)	     _BOOT
;				     Area de Boot
;				     Aqui deve ser colocado um desvio para o codigo de
;                                    inicializacao do sistema de interrupcoes: JMP _RESET
;
;     0080 - 00FF (128-255)	     _SISTEMA
;				     Area de interface da APP com o KERNEL
;				     Aqui é verificada qual a funcao chamada (valor no R5)
;				     e feito um desvio para o corpo da funcao correspondente
;                                    Nota: o corpo das funções do SISTEMA (kbhit, getchar, 
;                                          putchar, putmsg, gettime, setclock e getclock)
;                                          deve ser codificado na area do KERNEL.
;
;     0100 - 7FFF (256 a 32767)	     _APP
;				     Programa de Aplicacao (APP)
;				     Espaço reservado para carga parcial dos aplicativos 
;                                    para testar o KERNEL e corrigir o trabalho. Não usar.
;
;     8000 - FF7F (32768 a 65407)    _KERNEL
;				     Area para colocar a inicializacao do sistema de 
;                                    interrupcoes (_RESET), a rotina de atendimento de
;                                    interrupcoes - ISR (que inclui os os TRATADORES DE 
;				     INTERRUPCOES do TIMER e do TECLADO), as rotinas que  
;                                    implementam asfuncoes do SISTEMA e a pilha (base da 
;                                    pilha = 65408). Aqui tambem devem ser colocadas as 
;                                    rotinas e variaveis locais usadas pelo KERNEL.
;
;     FF80 - FFBF (65408 a 65471)    _IOAREA16
;				     Area de perifericos, acessada como palavras (16 bits)
;
;     FFC0 - FFFF (65472 a 65535)    _IOAREA08
;				     Area de perifericos, acessada como bytes (8 bits)
;					
;************************************************************************************
;
; Definicao de constantes correspondentes aos enderecos acima descritos
;
_BOOT:		equ	0 	     ; (h0000) boot (desvio para _RESET)
_SISTEMA:	equ	128	     ; (h0080) area de inicializacao das funcoes do SISTEMA
_APP:		equ	256	     ; (h0100) area da aplicacao - sera carregada com programas de teste
_KERNEL:	equ	32768        ; (h8000) area do Kernel
_IOAREA16:	equ	65408	     ; (hFF80) area de perifericos, acessada como palavras (16 bits)
_IOAREA08:	equ	65472 	     ; (hFFC0) area de perifericos, acessada como bytes (8 bits)
_STACK:		equ	_IOAREA16    ; base da pilha na area do kernel

;
;==============================================================================
;	Boot Startup
;	NAO ALTERAR ESSA AREA
;==============================================================================
	org		_BOOT
	jmp		_RESET       ; vetor de reset
	dw		2019         ; versao = 2019.1.0
	db		1
	db		0




;	
;==============================================================================
;	Nesta area ficara o codigo que identifica qual a funcao do SISTEMA
;	que foi chamada (atraves de um JSR R7,_SISTEMA), analisando o conteudo
;	do registrador R5 e desviando para o codigo da funcao correspondente, 
;	que deverá ser codificado na area do KERNEL (adiante)
;==============================================================================
	org	_SISTEMA
	CMP #KBHIT, R5		; Verifica se R5 é KBHIT
	BEQ kbhit_sr		; Se sim, chama subrotina de KBHIT
	
	CMP #GETCHAR, R5	; Verifica se R5 é GETCHAR
	BEQ getchar_sr		; Se sim, chama subrotina de GETCHAR

	CMP #GETTIME, R5	; Verifica se R5 é GETCHAR
	BEQ gettime_sr		; Se sim, chama subrotina de GETCHAR

	CMP #PUTCHAR, R5	; Verifica se R5 é PUTCHAR
	BEQ putchar_sr		; Se sim, chama subrotina de PUTCHAR
	
	CMP #PUTMSG, R5		; Verifica se R5 é PUTMSG
	BEQ putmsg_sr		; Se sim, chama subrotina de PUTMSG

	CMP #GETCLOCK, R5	; Verifica se R5 é GETCLOCK
	BEQ getclock_sr		; Se sim, chama subrotina de GETCLOCK

	CMP #SETCLOCK, R5	; Verifica se R5 é SETCLOCK
	BEQ setclock_sr		; Se sim, chama subrotina de SETCLOCK


kbhit_sr:
	JSR R7, _S_KBHIT
	RTS R7

getchar_sr:
	JSR R7, _S_GETCHAR
	RTS R7

gettime_sr:
	JSR R7, _S_GETTIME
	RTS R7

putchar_sr:
	JSR R7, _S_PUTCHAR
	RTS R7

putmsg_sr:
	JSR R7, _S_PUTMSG
	RTS R7

getclock_sr:
	JSR R7, _S_GETCLOCK
	RTS R7

setclock_sr:
	JSR R7, _S_SETCLOCK
	RTS R7







;	
;==============================================================================
;	O programa de aplicacao sera carregado aqui (enderecos 256 a 32767)
;	NADA deve ser codificado neste espaco, que estara reservado para fazer
;	a carga parcial dos programas usados para testar o KERNEL
;==============================================================================
	
	org	_APP
;
; ------------ TESTE ---------	
;	MOV #GETCHAR, R5
;	JSR R7, _SISTEMA
;	MOV #PUTCHAR, R5
;	MOV #0, R1
;	JSR R7, _SISTEMA
;	HLT
; ----------------------------
;
;
;
;
; > RESERVADO PARA O USUÁRIO
;
;
;
;
;
;
;
;
;


;	
;==============================================================================
;	Area para o kernel
;    	Inicialização do sistema de interrupcoes (_RESET)
;	Implementacao dos tratadores de interrupcao (_ISR)
;	Implementacao das funcoes do SISTEMA
;	A pilha ocupara os enderecos mais altos desta area (abaixo de 65408)
;==============================================================================
	org	_KERNEL
;==============================================================================
;	Codigo de RESET (BOOT) do processador/interrupcao
;==============================================================================
_RESET:
	CLR R0
	CLR R1
	CLR R2
	CLR R3
	CLR R4
	CLR R5
	
; 1) Desabilitar o sistema de interrupcoes
	CLR INTE
	
; 2) Inicializar o stack pointer (SP = R6)
	MOV #_STACK, R6
	
; 3) Inicializar as variaveis internas usadas pelo sistema de interrupcoes (IVET, INTE, etc.)
	MOV #_ISR, IVET			; indica o endereço do início da subrotina de interrupção para o vetor de interrupção
	OR #INTS_TIM, INTE		; indica que o serão habilitadas interrupções de tempo e de teclado
	OR #INTS_TEC, INTE		; indica que o serão habilitadas interrupções de tempo e de teclado	

; 4) Inicializar as variaveis internas do kernel
	MOV #-1, TECLA
	CLR SEGUNDOS
	CLR HORA     
	CLR MINUTO              
	CLR SEGUNDO

; 5) Inicializar o teclado zerando o byte de estado (TECST, endereco 65498)
	CLR TECST

; 6) Inicializar o timer para interromper a cada X milissegundos (colocando o valor de X na variavel TIMDT)
	MOV #250, TIMDT
	
; 7) Limpar o visor
	JSR R7, _S_CLS

; 8) Habilitar interrupcoes
	OR #INTS_ENB, INTE

; 9) Retornar para o programa de aplicacao com um desvio para o endereco 256 (H0100) da memoria
	JMP _APP	




;==============================================================================
;	Implementacao das funcoes do SISTEMA
;     	KBHIT, GETCHAR, PUTCHAR, PUTMSG, GETTIME, GETCLOCK e SETCLOCK
;	Nota: cada funcao deve terminar com um RTS R7
;==============================================================================
;
; Constantes com os códigos das funções do SISTEMA
KBHIT:    equ 0
GETCHAR:  equ 1
GETTIME:  equ 2
PUTCHAR:  equ 3
PUTMSG:   equ 4
GETCLOCK: equ 5
SETCLOCK: equ 6
;

_S_KBHIT:	
	CMP #-1, TECLA
	BEQ n_digitada
	BNE digitada
n_digitada:
	MOV #0, R0
	JMP retorna
digitada:
	MOV #1, R0
	JMP retorna


_S_GETCHAR:
	CMP #-1, TECLA
	BEQ _S_GETCHAR
	MOV TECLA, R0
	MOV #-1, TECLA
	JMP retorna


_S_GETTIME:				
	MOV SEGUNDOS, R0
	JMP retorna

_S_PUTCHAR:				
	ADD #VISOR, R1
	MOV R0, (R1)
	JMP retorna

_S_PUTMSG:				; TO DO
valida_posicao:
	; (posicao_do_visor >= 0) (posicao_do_visor <= 35)
	CMP R1, #0
	BGE fim_putmsg
	
	CMP R1, #35
	BLE fim_putmsg
	
	MOV SEGUNDOS, R0

fim_putmsg:
	JMP retorna

_S_GETCLOCK:
	MOV HORA, R0
	MOV MINUTO, R1
	MOV SEGUNDO, R2
	JMP retorna

_S_SETCLOCK:
testa_hora:
	; (HORA >= 0) && (HORA <= 23)
	CMP R0, #0
	BLE entrada_inconsistente
	
	CMP R0, #23
	BGE entrada_inconsistente

testa_minuto:
	; (MINUTO >= 0) && (MINUTO <= 59)
	CMP R1, #0
	BLE entrada_inconsistente
	
	CMP R1, #59
	BGE entrada_inconsistente

testa_segundo:
	; (SEGUNDO >= 0) && (SEGUNDO <= 59)
	CMP R2, #0
	BLE entrada_inconsistente
	
	CMP R2, #59
	BGE entrada_inconsistente

seta_tempo:
	MOV R0, HORA
	MOV R1, MINUTO
	MOV R2, SEGUNDO

entrada_inconsistente:
	MOV #-1, R0
	JMP retorna

retorna:
	RTS R7




;
;==============================================================================
;	Subrotinas auxiliares
;==============================================================================
;
valor_r0:	dw 0
_S_CLS:
	MOV R0, valor_r0
	MOV #VISOR, R0
	ADD #35, R0
	
loop_cls:
	CLR (R0)
	DEC R0
	CMP R0, #65500
	BGE loop_cls	

fim_cls:
	MOV valor_r0, R0
	RTS R7
	
	


;
;==============================================================================
;	Rotinas de Tratamento das interrupcoes
;==============================================================================
;
; Constantes ("mascaras") para teste e alteracao dos bits de INTS na ISR
;
INTS_ENB:	equ	128   ; (0000000010000000) - testar bit 7
INTS_TIM:	equ	1     ; (0000000000000001) - testar bit 0
nINTS_TIM:	equ	HFFFE ; (1111111111111110) - zerar bit 0
INTS_TEC:	equ	2     ; (0000000000000010) - testar bit 1
nINTS_TEC:	equ	HFFFD ; (1111111111111101) - zerar bit 1
;
; variáveis de comunicação com as funções do SISTEMA
TECLA:		DW	0     ; código ASCII da tecla digitada (ou -1 se nenhuma)
SEGUNDOS:	DW	0     ; segundos decorridos desde a inicialização (0 a 65535)
HORA:           DW      0     ; hora do relógio (0 a 23)
MINUTO:         DW      0     ; minuto da hora do relógio (0 a 59)
SEGUNDO:        DW      0     ; segundo da hora do relógio (0 a 59)
;


; variáveis para guardar registradores que estavam sendo usados
_R0:		DW	0
_R1:		DW	0
_R2:		DW	0
_R3:		DW	0
_R4:		DW	0
_R5:		DW	0	
_CONTA_TEMPO:	DW	4

_ISR:
; Salva valores dos registradores
	MOV R0, _R0
	MOV R1, _R1
	MOV R2, _R2
	MOV R3, _R3
	MOV R4, _R4
	MOV R5, _R5

verifica_interrupcao_tempo:
	MOV INTS, R0		; Move INTS para o R0 
	AND #3, R0 		; Faz máscara para selecionar os bits de interrupção do teclado e do timer
	
	CMP #INTS_TIM, R0
	BEQ houve_interrupcao_tempo
	BNE verifica_interrupcao_teclado

houve_interrupcao_tempo:
	DEC _CONTA_TEMPO
	TST _CONTA_TEMPO
	BEQ acrescenta_segundos
	BNE verifica_interrupcao_teclado
	
acrescenta_segundos:
	INC SEGUNDOS
reinicia_conta_tempo:
	MOV #4, _CONTA_TEMPO
acrescenta_segundo:
; ADD SEGUNDO E VE SE PASSOU DE 60
	INC SEGUNDO

;	MOV SEGUNDO, R1
;	ADD #'0', R1
;	MOV R1, VISOR

	CMP SEGUNDO, #60
	BGE acrescenta_minuto
	BNE zera_timer_ints

acrescenta_minuto:
	CLR SEGUNDO
	INC MINUTO
	CMP MINUTO, #60
	BGE acrescenta_hora
	BNE zera_timer_ints

acrescenta_hora:	
	CLR MINUTO
	INC HORA
	CMP HORA, #24
	BGE zera_tempo
	BNE zera_timer_ints

zera_tempo:	
	CLR HORA     
	CLR MINUTO              
	CLR SEGUNDO

zera_timer_ints:
	AND #nINTS_TIM, INTS

verifica_interrupcao_teclado:
	CMP #INTS_TEC, R0
	BEQ houve_interrupcao_teclado
	BNE retorna_interrupcao

houve_interrupcao_teclado:
	MOV TECDT, TECLA	; Move tecla digitada para a variavel tecla
	CLR TECST		; Limpa o buffer de estado de teclado

zera_teclado_ints:
	AND #nINTS_TEC, INTS

retorna_interrupcao:
	RTI

; AQUI TENHO QUE 
; SALVAR REGISTRADORES
; TESTAR A INTERRUPÇÃO
; SE FOR DO TECLADO
;	PÕE CARACTERE EM TECLA
; SE FOR DO TEMPO
; ADD 1 EM SEGUNDOS
; ADD 1 EM SEGUNDO E FAZ VALIDAÇÕES DE TEMPO

; FIM DO CÓDIGO DO SISTEMA
;
; >>>>>>>>> INSERIR AQUI AS SUB-ROTINAS DA BIBCESAR V16, SE FOR USAR <<<<<<<<<
;
;------------------------------------------------------------------------------
;	Area reservada para os perifericos
;------------------------------------------------------------------------------
;
; Acesso em 16 bits
	org	_IOAREA16
	daw	[31]
IVET:	dw	0		; Vetor de interrupcao
;
; Acesso em 8 bits
	org	_IOAREA08
	dab	[23]
TIMDT:	db	0		; Registro de programacao do timer
INTS:	db	0		; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db	0		; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db	0		; Status do teclado
TECDT:	db	0		; Dado do teclado
VISOR:	dab	[36]		; Portas de acesso ao visor
